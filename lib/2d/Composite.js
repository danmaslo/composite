const Vector = require('./Vector.js');
const Circle = require('./Circle.js');
const Fs = require('fs');

class Composite {
	// constructor
    constructor(width, height, bounds) {
		this._width = width;
		this._height = height;
		this._bounds = bounds;

		this._objects = [];
    }


	// constants
	static get PERIODIC() {
		return(0);
	}

	static get NON_PERIODIC() {
		return(1);
	}


	// getters and setters
	getWidth() {
		return this._width;
	}

	setWidth(width) {
		this._width = width;
	}

	getHeight() {
		return this._height;
	}

	setHeight(height) {
		this._height = height;
	}

	getBounds() {
		return this._bounds;
	}

	// TODO check input type as one of the bounds consts
	setBounds(bounds) {
		this._bounds = bounds;
	}

	getObjects() {
		return this._objects;
	}


	// public methods
	getArea() {
		return(this._width * this._height);
	}

	toSvg(title) {
		var svg = "";

		svg = svg + "<?xml version=\"1.0\" standalone=\"no\" ?>\n";
        svg = svg + "<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n";
        svg = svg + "<svg width=\"" + this._width + "\" height=\"" + this._height + "\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\">\n";
        svg = svg + "<title>" + title + "</title>\n";
        svg = svg + "<desc>generated by https://github.com/danmaslo/composite</desc>\n\n";

            // objects
            for (var i = 0; i < this._objects.length; i++) {
                svg = svg + this._objects[i].toSvg();
            }

        svg = svg + "</svg>";

		return(svg);
	}

	saveSvg(filename) {
		Fs.writeFile(filename + ".svg", this.toSvg(filename), function (err) {
			if (err) return console.log(err);
		});
	}

	/**
		returns true if Circle c is in the composite bounds
	*/
	isIn(c) {
		if (this._bounds == Composite.NON_PERIODIC) {
			if ((c.getRadius() <= c.getCenter().getX()) && ((c.getCenter().getX() + c.getRadius()) <= this._width) && (c.getRadius() <= c.getCenter().getY()) && ((c.getCenter().getY() + c.getRadius()) <= this._height)) {
				return(true);
			}
			else {
				return(false);
			}
		}
		else if (this._bounds == Composite.PERIODIC) {
			return(true);
		}
	}

	add(c) {
		if (this.isIn(c)) {
			for (var i = 0; i < this._objects.length; i++) {
				if (Circle.isOverlap(c, this._objects[i])) {
					return(false);
				}
				if (this._bounds == Composite.PERIODIC) {
					var cxLeft = Circle.copyConstructor(c);
					var cxRight = Circle.copyConstructor(c);
					var cyTop = Circle.copyConstructor(c);
					var cyBottom = Circle.copyConstructor(c);
					var cTopLeft = Circle.copyConstructor(c);
					var cTopRight = Circle.copyConstructor(c);
					var cBottomLeft = Circle.copyConstructor(c);
					var cBottomRight = Circle.copyConstructor(c);

					cxLeft.move(new Vector(this._width, 0));
					cxRight.move(new Vector(-1 * this._width, 0));
					cyTop.move(new Vector(0, this._height));
					cyBottom.move(new Vector(0, -1 * this._height));
					cTopLeft.move(new Vector(-1 * this._width, -1 * this._height));
					cTopRight.move(new Vector(this._width, -1 * this._height));
					cBottomLeft.move(new Vector(-1 * this._width, this._height));
					cBottomRight.move(new Vector(this._width, this._height));

					if (Circle.isOverlap(this._objects[i], cxLeft) || Circle.isOverlap(this._objects[i], cxRight) || Circle.isOverlap(this._objects[i], cyTop) || Circle.isOverlap(this._objects[i], cyBottom) || Circle.isOverlap(this._objects[i], cTopLeft) || Circle.isOverlap(this._objects[i], cTopRight) || Circle.isOverlap(this._objects[i], cBottomLeft) || Circle.isOverlap(this._objects[i], cBottomRight)) {
							return(false);
					}
				}
			}

			this._objects.push(c);
			return(true);
		}
		else {
			return(false);
		}
	}
}

module.exports = Composite;
