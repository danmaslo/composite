const Vector = require('./Vector.js');
const Circle = require('./Circle.js');
const Fs = require('fs');

class Composite {
	// constructor
    constructor(initObj) {
		this._width = initObj.width;
		this._height = initObj.height;
		this._bounds = initObj.bounds;

		this._objects = [];
    }


	// constants
	static get PERIODIC() {
		return(0);
	}

	static get NON_PERIODIC() {
		return(1);
	}

    static get BF() {
        return(2);
    }

    static get PIC() {
        return(3);
    }


	// getters and setters
	getWidth() {
		return this._width;
	}

	setWidth(width) {
		this._width = width;
	}

	getHeight() {
		return this._height;
	}

	setHeight(height) {
		this._height = height;
	}

	getBounds() {
		return this._bounds;
	}

	// TODO check input type as one of the bounds consts
	setBounds(bounds) {
		this._bounds = bounds;
	}

	getObjects() {
		return this._objects;
	}


	// public methods
	getArea() {
		return(this._width * this._height);
	}

	toSvg(title) {
		var svg = "";

		svg = svg + "<?xml version=\"1.0\" standalone=\"no\" ?>\n";
        svg = svg + "<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n";
        svg = svg + "<svg width=\"" + this._width + "\" height=\"" + this._height + "\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\">\n";
        svg = svg + "<title>" + title + "</title>\n";
        svg = svg + "<desc>generated by https://github.com/danmaslo/composite</desc>\n\n";

            // objects
            for (var i = 0; i < this._objects.length; i++) {
                svg = svg + this._objects[i].toSvg();
            }

        svg = svg + "</svg>";

		return(svg);
	}

	saveSvg(filename) {
		Fs.writeFile(filename + ".svg", this.toSvg(filename), function (err) {
			if (err) return console.log(err);
		});
	}

	/**
		returns true if Circle c is in the composite bounds
	*/
	isIn(c) {
		if (this._bounds == Composite.NON_PERIODIC) {
			if ((c.getRadius() <= c.getCenter().getX()) && ((c.getCenter().getX() + c.getRadius()) <= this._width) && (c.getRadius() <= c.getCenter().getY()) && ((c.getCenter().getY() + c.getRadius()) <= this._height)) {
				return(true);
			}
			else {
				return(false);
			}
		}
		else if (this._bounds == Composite.PERIODIC) {
			return(true);
		}
	}

	add(c) {
		if (this.isIn(c)) {
			for (var i = 0; i < this._objects.length; i++) {
				if (Circle.isOverlap(c, this._objects[i])) {
					return(false);
				}
				if (this._bounds == Composite.PERIODIC) {
					var cxLeft = Circle.copyConstructor(c);
					var cxRight = Circle.copyConstructor(c);
					var cyTop = Circle.copyConstructor(c);
					var cyBottom = Circle.copyConstructor(c);
					var cTopLeft = Circle.copyConstructor(c);
					var cTopRight = Circle.copyConstructor(c);
					var cBottomLeft = Circle.copyConstructor(c);
					var cBottomRight = Circle.copyConstructor(c);

					cxLeft.move(new Vector(this._width, 0));
					cxRight.move(new Vector(-1 * this._width, 0));
					cyTop.move(new Vector(0, this._height));
					cyBottom.move(new Vector(0, -1 * this._height));
					cTopLeft.move(new Vector(-1 * this._width, -1 * this._height));
					cTopRight.move(new Vector(this._width, -1 * this._height));
					cBottomLeft.move(new Vector(-1 * this._width, this._height));
					cBottomRight.move(new Vector(this._width, this._height));

					if (Circle.isOverlap(this._objects[i], cxLeft) || Circle.isOverlap(this._objects[i], cxRight) || Circle.isOverlap(this._objects[i], cyTop) || Circle.isOverlap(this._objects[i], cyBottom) || Circle.isOverlap(this._objects[i], cTopLeft) || Circle.isOverlap(this._objects[i], cTopRight) || Circle.isOverlap(this._objects[i], cBottomLeft) || Circle.isOverlap(this._objects[i], cBottomRight)) {
						return(false);
					}
				}
			}

			this._objects.push(c);
			return(true);
		}
		else {
			return(false);
		}
	}

    /**
        generates composite from initObject

        {
        	"until": { // stop when reach first of something
        		"time": 3600, // 1 hour
        		"ff": 0.64, // filling factor
        		"tries": 1000000 // number of random particles
        	},
        	"method": Composite.PIC,
        	"particles": [
        		{
        			"radius": 1,
        			"probability": 0.5
        		},
        		{
        			"radius": 5,
        			"probability": 0.5
        		}
        	]
        }
     */
    generate(initObj) {
        if ((initObj.until != null) && (initObj.particles != null)) {
            var untilTries = (initObj.until.tries != null) ? initObj.until.tries : -1;
            var untilFf = (initObj.until.ff != null) ? initObj.until.ff : -1;
            var untilTime = (initObj.until.time != null) ? initObj.until.time : -1;

            var tries = 0;
            var ff = 0;
            var time = 0;

            // check radius probabilities
            var sum = 0;

            for (var i = 0; i < initObj.particles.length; i++) {
                sum += initObj.particles[i].probability;
            }

            if (Math.abs(sum - 1) <= 0.0001) {
                var probabilities = [];

                for (var i = 0; i < initObj.particles.length; i++) {
                    probabilities[i] = initObj.particles[i].probability;

                    if (i != 0) {
                        probabilities[i] = probabilities[i] + probabilities[i - 1];
                    }
                }
            }
            else {
                console.log("probabilities in composite.generate() method are not 1 sumed up together");
                process.exit();
            }

            // build composite
            while(true) {
                // generate Circle to add
                var x = this._width * Math.random();
                var y = this._height * Math.random();

                var rand = Math.random();
                var r = -1;

                for (var i = 0; i < probabilities.length; i++) {
                    if (rand < probabilities[i]) {
                        r = initObj.particles[i].radius;
                        break;
                    }
                }

                // add
                this.add(new Circle(new Vector(x, y), r));

                // update stoppers
                tries += 1;

                // TODO update time and FF

                // break the loop
                if ((tries >= untilTries) && (untilTries > 0)) {
                    break;
                }
                if ((ff >= untilFf) && (untilFf > 0)) {
                    break;
                }
                if ((time >= untilTime) && (untilTime > 0)) {
                    break;
                }
            }
        }
        else {
            console.log("missing UNTIL or PARTICLES argument in composite.generate() method");
            process.exit();
        }
    }
}

module.exports = Composite;
